% Static planner for multi-agent path finding for grid maps and the makespan objective
% using train motion on agents
% swap is forbidden

import sat.

main([InsFile]) =>
    %printf("solving %s\n",InsFile),
    cl(InsFile),
    main.

main =>
    ins(Graph, As, IB),                   % read input
    cl_facts(Graph,[$neibs(+,-)]),
    N = len(Graph),                     % N = number of nodes
    create_edges(N, E),                 % E = number of edges
    time(once(path(N,E,to_array(As),IB,B))),
    output_plan(B).

test =>
    testins(Graph, As, IB),                   % read input
    cl_facts(Graph,[$neibs(+,-)]),
    N = len(Graph),                     % N = number of nodes
    create_edges(N, E),                 % E = number of edges
    time(once(path(N,E,to_array(As),IB,B))),
    output_plan(B).


%%%%%%%%%%%%%%%%%%%%
% MAIN COMPUTATION %
%%%%%%%%%%%%%%%%%%%%

path(N,E,As,IB,B) =>
    K = len(As),
    M = len(IB),
    ME = M - 1,

    B = new_array(M,K,N),
    C = new_array(ME,K,E),

    foreach (T in 1..M, A in 1..K)
        set_B(IB[T,A],B[T,A],0)
    end,

    %printf("arrays completed!\n"),

    % Initialize the first and last states
    foreach(A in 1..K)    
        (V,FV) = As[A],
        B[1,A,V] = 1,
        B[M,A,FV] = 1,
        preprocess_edges(K,N,ME,B,E,C)
    end,

    %printf("preprocessing done!\n"),

    %printf("B %w\n",B),

    B :: 0..1,
    C :: 0..1,

    %printf("B %w\n",B),

    % Each agent occupies up to one vertex at each time.
    foreach (T in 1..M, A in 1..K)
        sum([B[T,A,V] : V in 1..N]) #=< 1
    end,

    % No two agents occupy the same vertex at any time.
    foreach(T in 1..M, V in 1..N) 
        sum([B[T,A,V] : A in 1..K]) #=< 1   
    end,

    % if an edge is used in one direction, it can not be used in the other direction (no swap)
    foreach(T in 1..ME, EID in 1..E) 
        edgeid(EID, U, V),
    	edge(OppositeEID, V, U),
        EList = remove_dups([EID,OppositeEID]),
    	sum([C[T,A,W] : A in 1..K, W in EList]) #=< 1   
    end,

    % if an agent is in a node, it needs to move through one of the edges from that node
    foreach(T in 1..ME, A in 1..K, V in 1..N) 
    	out_edges(V,EList),
        B[T,A,V] #=> sum([C[T,A,W] : W in EList]) #= 1
    end,

    % if agent is using an edge, it must arrive to the connected node in next timestep
    foreach(T in 1..ME, A in 1..K, EID in 1..E) 
        edgeid(EID,_,V),
        C[T,A,EID] #=> B[T+1,A,V] #= 1
    end,

    %printf("solving start\n"),

    solve(B).
    %printf("^ time of SAT solving\n").


%%%%%%%%%%%%%%%%%%%%%
% UTILITY FUNCTIONS %
%%%%%%%%%%%%%%%%%%%%%

% if agent can not be in a vertex, then he could not use any edge connected to it
preprocess_edges(K,N,M1,B,E,C) =>
    % outgoing edges
	foreach(A in 1..K, T in 1..M1-1, V in 1..N)
		if B[T,A,V] == 0 then
            out_edges(V,EList),
			foreach(EID in EList)
                C[T,A,EID] = 0
			end
		end
	end,

    % incoming edges - works only for undirected graphs!!!
	foreach(A in 1..K, T in 2..M1, V in 1..N)
		if B[T,A,V] == 0 then
            out_edges(V,EList),
            foreach(EID in EList)
                edgeid(EID, V, U),
                edge(OppositeEID, U, V),
                C[T-1,A,OppositeEID] = 0
            end
        end
	end.

%
set_B([X|IB],B,Prev) =>
    foreach(V in Prev+1..X-1)
        B[V] = 0
    end,
    set_B(IB,B,X).

set_B([],B,Prev) =>
    foreach(V in Prev+1..len(B))
        B[V] = 0
    end.

% create $edge from $neibs
create_edges(N, E) =>
	Ed1 = [],
    Ed2 = [],
	EID = 1,
	foreach(V in 1..N)
		neibs(V,Neibs),
		L = len(Neibs),
		foreach(I in 1..L)
			Ed1 := [$edge(EID, V, Neibs[I])|Ed1],
            Ed2 := [$edgeid(EID, V, Neibs[I])|Ed2],
			EID := EID + 1
		end
	end,

    cl_facts(Ed1,[$edge(-,+,+)]),
    cl_facts(Ed2,[$edgeid(+,-,-)]),
    E = len(Ed1).


% for node W, get list of outgoing edges
out_edges(W,EList) =>
	ETMP = [],
    neibs(W,Neibs),
    L = len(Neibs),
    foreach(I in 1..L)
        edge(EID,W,Neibs[I]),
        ETMP := [EID] ++ ETMP
	end,
	EList = ETMP.

output_plan(B) =>
    M = len(B) - 1,
    K = len(B[1]),
    N = len(B[1,1]),
    printf("agents | timesteps\n"),
    printf("%w %w\n",K,M+1),
    %printf("timesteps %w\n",M+1),
	foreach (A in 1..K)
		foreach (T in 1..M+1)
			foreach (V in 1..N)
				if B[T,A,V] == 1 then
					printf("%w ",V)
				end
			end
		end,
        nl
	end.


%%%%%%%%%%%%%%%
% TEST INPUTS %
%%%%%%%%%%%%%%%

testins(Graph, As, B) =>
    Graph = [
    $neibs(1,[1,3]),
    $neibs(2,[2,3]),
    $neibs(3,[3,4,1,2]),
    $neibs(4,[4,3,5,6]),
    $neibs(5,[5,4]),
    $neibs(6,[6,4])
    ],
    As = [(1,5)],
    B = new_array(5,1),
    B[1,1] = flatten([1..3]),
    B[2,1] = flatten([3,5]),
    B[3,1] = flatten([4]),
    B[4,1] = flatten([1,3,5..6]),
    B[5,1] = flatten([5]).
